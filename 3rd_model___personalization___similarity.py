# -*- coding: utf-8 -*-
"""3rd model _ personalization _ similarity .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sQ18dTX62HxLgOqi1hvRt1xy4d2Ua1_u

## Recommendation System Documentation

### Overview

This document provides a detailed explanation of the recommendation system's methodology, focusing on the logical flow and processes defined in the code. The system recommends products to both existing and new users by utilizing different strategies.

### Components

1. **Loading the Dataset**
    - The system begins by loading the dataset containing user interactions from a specified CSV file. This dataset includes attributes such as `User_ID`, `product_id_cleaned`, `event_name`, `button_name1`, and other relevant interaction details.

2. **Recommendation Functions**

    **Existing Users**
    - The system recommends items to existing users based on their historical interactions. The methodology involves:
      1. Extracting the product interaction history of the target user by filtering the dataset for entries corresponding to the user's ID.
      2. Identifying similar users by finding those who have interacted with the same products as the target user.
      3. Excluding the target user from this set of similar users to avoid self-recommendations.
      4. Aggregating the interaction histories of these similar users to identify frequently interacted products.
      5. Excluding products the target user has already interacted with to provide novel recommendations.
      6. Recommending the top N products from the aggregated list of frequently interacted items.

    **New Users with Event Data**
    - For new users who have interacted with a product, the system recommends items based on the interactions of other users who have interacted with the same product. The steps include:
      1. Identifying users who have interacted with the same product as the new user by filtering the dataset for entries corresponding to the product.
      2. Aggregating the interaction histories of these similar users to identify frequently interacted products.
      3. Excluding the initially interacted product from the recommendations to ensure diversity.
      4. Recommending the top N products from the aggregated list of frequently interacted items.

    **Popular Items**
    - For new users without any interaction or demographic data, the system recommends the most popular items. The methodology includes:
      1. Calculating the frequency of interactions for each product in the dataset by counting occurrences.
      2. Sorting products based on their interaction frequency in descending order.
      3. Recommending the top N products from the sorted list, representing the most popular items in the dataset.

3. **Logging New User Interactions**
    - The system includes functionality to log interactions of new users. This involves:
      1. Capturing interaction details such as `User_ID`, `product_id_cleaned`, `event_name`, and `button_name1`.
      2. Creating a new entry in the dataset with these details.
      3. Concatenating this new entry to the existing dataset to ensure it remains updated with the latest interactions.

4. **Main Recommendation Function**
    - This function determines the user status (existing or new) and recommends items accordingly. The steps include:
      1. Checking if the user ID exists in the dataset to determine if the user is an existing or new user.
      2. For existing users, invoking the function to recommend items based on historical interactions.
      3. For new users with event data, invoking the function to recommend items based on similar interactions.
      4. For new users without any interaction data, invoking the function to recommend popular items.
      5. Returning the list of recommended items to the user.

5. **Processing User Interactions**
    - This component handles the overall process of recommending items and logging interactions. The steps include:
      1. Checking if the user exists in the dataset.
      2. Recommending items based on the user's status (existing or new).
      3. Logging interactions for new users to update the dataset.
      4. Ensuring the dataset is continuously updated with new interactions for accuracy in future recommendations.

### Data Size Information

- **Df1**: Contains 2,897,439 rows and 44 columns (after date 1/6).
- **Df2**: Contains 2,553,571 rows and 44 columns (before date 1/6).
- **Full filtered data**: Contains 603,628 rows and 23 columns.

### Methodology

1. **Data Preparation**
    - The dataset is loaded from a CSV file containing user interaction details. This step ensures the dataset is ready for further processing.

2. **User Status Identification**
    - The system checks if the user ID exists in the dataset to determine if the user is an existing or new user. This step helps in applying the appropriate recommendation strategy.

3. **Recommendation for Existing Users**
    - The user's historical interactions are analyzed to find similar users who have interacted with the same products. The products frequently interacted with by these similar users are identified and recommended, excluding products already interacted with by the target user. This ensures personalized and relevant recommendations.

4. **Recommendation for New Users with Event Data**
    - The system identifies users who have interacted with the same product as the new user and aggregates their interaction histories. It then recommends frequently interacted products, excluding the initially interacted product. This approach leverages the event data to provide relevant recommendations.

5. **Recommendation for New Users without Data**
    - The system calculates the frequency of interactions for each product in the dataset, sorts products based on their interaction frequency, and recommends the top N products. This strategy ensures popular items are recommended to new users without any interaction or demographic data.

6. **Logging Interactions**
    - New user interactions are captured and logged into the dataset, keeping it current and accurate. This step is crucial for the continuous improvement of the recommendation system.

7. **Continuous Improvement**
    - The system continuously updates the dataset with new interactions, allowing the recommendation engine to learn from new data and improve its suggestions over time. This iterative process ensures the recommendations remain relevant and personalized.

### Summary

This recommendation system efficiently handles recommendations for both existing and new users by leveraging historical interactions, event data, and popular items. It includes functionality to log new user interactions, ensuring the dataset remains up-to-date for future recommendations. This approach ensures personalized and relevant product suggestions for users, enhancing their overall experience.
"""

import pandas as pd

# Load your dataset
df = pd.read_csv('/content/drive/MyDrive/TwentyToo/df1&df2_impute_ages_all_filtered_clean2+interactions.csv')

# Function to recommend items for an existing user based on historical interactions
def recommend_for_existing_user(user_id, data, top_n=5):
    user_history = data[data['User_ID'] == user_id]['product_id_cleaned']
    similar_users = data[data['product_id_cleaned'].isin(user_history)]['User_ID'].unique()
    similar_users = similar_users[similar_users != user_id]  # Exclude the target user

    similar_users_history = data[data['User_ID'].isin(similar_users)]
    recommended_products = similar_users_history['product_id_cleaned'].value_counts().index

    # Exclude products the target user has already interacted with
    recommended_products = [product for product in recommended_products if product not in user_history.values][:top_n]

    return recommended_products

# Function to recommend items for a new user with event data
def recommend_for_new_user_with_events(product_interacted, data, top_n=5):
    similar_users = data[data['product_id_cleaned'] == product_interacted]['User_ID'].unique()
    if len(similar_users) > 0:
        similar_users_history = data[data['User_ID'].isin(similar_users)]
        recommended_products = similar_users_history['product_id_cleaned'].value_counts().index
        recommended_products = [product for product in recommended_products if product != product_interacted][:top_n]
        return recommended_products
    else:
        return recommend_popular_items(data, top_n)

# Function to recommend popular items for a new user without demographic data
def recommend_popular_items(data, top_n=5):
    popular_items = data['product_id_cleaned'].value_counts().index[:top_n]
    return popular_items

# Function to log new user interactions and update the dataset
def log_user_interaction(user_id, product_id, event_name, button_name1, data):
    interaction_weight = 1  # Placeholder for actual interaction weight calculation
    new_interaction = pd.DataFrame({
        'city': [None],  # Placeholder for actual city value
        'region': [None],  # Placeholder for actual region value
        'User_ID': [user_id],
        'button_name1': [button_name1],
        'age': [None],  # Placeholder for actual age value
        'age_group': [None],  # Placeholder for actual age group value
        'product_id_cleaned': [product_id],
        'event_name': [event_name],
        'interaction': [interaction_weight]
    })
    updated_data = pd.concat([data, new_interaction], ignore_index=True)
    return updated_data

# Main function to recommend items based on user status
def recommend_items_for_user(user_id=None, age=None, city=None, product_interacted=None, data=None, top_n=5):
    if user_id and user_id in data['User_ID'].unique():
        print(f"User {user_id} exists. Recommending based on history.")
        recommendations = recommend_for_existing_user(user_id, data, top_n)
        return recommendations
    elif product_interacted:
        print(f"New user with event data. Recommending based on similar interactions.")
        recommendations = recommend_for_new_user_with_events(product_interacted, data, top_n)
        return recommendations
    else:
        print("New user without demographics. Recommending popular items.")
        recommendations = recommend_popular_items(data, top_n)
        return recommendations

# Function to handle the user process
def process_user(user_id=None, age=None, city=None, product_interacted=None, event_interacted=None, button_interacted=None):
    global df
    if user_id in df['User_ID'].unique():
        print(f"User {user_id} exists. Recommending based on history.")
        recommendations = recommend_items_for_user(user_id=user_id, data=df)
    else:
        if product_interacted:
            print(f"User {user_id} does not exist. Recommending based on similar interactions and adding new user.")
            recommendations = recommend_items_for_user(user_id=user_id, age=age, city=city, product_interacted=product_interacted, data=df)
            df = log_user_interaction(user_id, product_interacted, event_interacted, button_interacted, df)
        else:
            print(f"User {user_id} does not exist. Recommending popular items and adding new user.")
            recommendations = recommend_items_for_user(data=df)
            df = log_user_interaction(user_id, product_interacted, event_interacted, button_interacted, df)

    print(f"Recommended items: {recommendations}")

    if user_id and product_interacted:
        print(f"Logging interaction for user {user_id}.")
        df = log_user_interaction(user_id, product_interacted, event_interacted, button_interacted, df)

# Example usage
if __name__ == "__main__":
    # Example user information
    user_id = 1  # Replace with actual user ID or None for new user
    new_user_age = None  # Replace with actual age or None if not available
    new_user_city = None  # Replace with actual city or None if not available
    product_interacted = None  # Example product interaction
    event_interacted = None  # Example event
    button_interacted = None # Example button interaction

    process_user(user_id=user_id, age=new_user_age, city=new_user_city, product_interacted=product_interacted, event_interacted=event_interacted, button_interacted=button_interacted)

